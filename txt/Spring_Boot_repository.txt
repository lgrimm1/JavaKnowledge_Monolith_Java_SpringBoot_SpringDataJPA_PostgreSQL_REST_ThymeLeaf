=================================================================================
SPRING BOOT REPOSITORY
=================================================================================
The Spring framework can identify a class as a repository.
That class will be responsible for storage management.
In case data will be stored in a database, a decision is needed whether the database will be SQL or NoSQL.

1. SPRING DATA
2. SPRING DATA JPA
3. SPRING DATA MONGODB
4. THE SPRING DATA DOMAIN-REPOSITORY CHAIN

=================================================================================
1. SPRING DATA
=================================================================================
1. SIMPLE SPRING DATA CLASS
2. DATA INTERFACES

1. SIMPLE SPRING DATA CLASS
---------------------------------------------------------------------------------
In case of Spring Data solution, this class will keep the data itself as well in some container of entities.
As a class it gives the structure and its methods but not the instance which will be hold by the service class.
In order to define a class as repository, the @Repository or @Component or @Bean annotation is needed, the first expresses its function better.
This class must be a singleton in memory per repository.
The class must be public in order to let Spring accessing it.

The simplest solution is to define a List<elementType> as a private field and its manipulation methods.
For smaller data amount it provides fast data access. The data will be hold in-memory and all methods must be declared in order to hold data in it.
In case of higher element number, the time needed for storage operations can be very high.
For keeping data in file system, the repository class can have load, save, find etc. methods which virtually mirror the in-memory data down to file system.

EXAMPLE FOR A REPOSITORY CLASS (SPRING DATA):
package PackageName;

import org.springframework.stereotype.*;

@Repository
public class RepositoryClassName {
    private final ...; //data container of entities e.g. a List or a Set
    //fields
    //constructor
    //getters
    //manipulation methods and helper methods
}
END OF EXAMPLE

2. DATA INTERFACES
---------------------------------------------------------------------------------
Spring Data offers several abstract interfaces stuffed with functionalities.
Upon coding, the repository should be an interface marked with the @Repository class-level annotation.
Spring Data will implement this interface into an automatically created singleton class and create an instance from it.

The standard interface is the Repository, all other interfaces are extended from this one.
The Repository interface is a generics, it needs two types in declaration:
    - EntityClassName: the class of the entity it manages
    - TypeOfID: the type of the entity ID field e.g. String or Long

EXAMPLE FOR A REPOSITORY INTERFACE:
package PackageName;

//for JPA
import org.springframework.data.jpa.repository.Repository;
import org.springframework.data.jpa.repository.Modifying;
import org.springframework.data.jpa.repository.Query;
//for MongoDB
import org.springframework.data.mongodb.repository.Repository;
import org.springframework.data.mongodb.repository.Modifying;
import org.springframework.data.mongodb.repository.Query;
//for all
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.*;

@Repository
public interface RepositoryClassName extends Repository<EntityClassName, TypeOfID> {
    //optional fields
    //optional overridden default methods
    //optional derived query methods
    //optional custom query methods
    //optional helper methods
}
END OF EXAMPLE

The interface must be public in order to let Spring accessing it.
The best solution is to engage with an in-memory or in-server database.
Such database can be H2 (in-memory) or PostgreSQL (or postgres) or mySQL or Oracle or MongoDB etc.
Visit the SPRING BOOT page for adding databases, and the SPRING APPLICATION PROPERTIES page for settings of databases.

||Interface|Description||
||Repository|the standard||
||CrudRepository|for adding CRUD operations (create, retrieve, update, delete); in case a method returns more elements, those will be provided in an Iterable||
||ListCrudRepository|for adding CRUD operations (for more elements it returns a List)||
||PagingAndSortingRepository|for adding paging and sorting operations (returns Iterable for more elements)||
||ListPagingAndSortingRepository|for adding paging and sorting operations (returns List for more elements)||

EXAMPLE FOR EXTENDING CRUD REPOSITORY INTERFACE:
package PackageName;

//for JPA
import org.springframework.data.jpa.repository.ListCrudRepository;
import org.springframework.data.jpa.repository.Modifying;
import org.springframework.data.jpa.repository.Query;
//for MongoDB
import org.springframework.data.mongodb.repository.ListCrudRepository;
import org.springframework.data.mongodb.repository.Modifying;
import org.springframework.data.mongodb.repository.Query;
//for all
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.*;

@Repository
public interface RepositoryClassName extends CrudRepository<EntityClassName, TypeOfID> {...}
END OF EXAMPLE

EXAMPLE FOR GIVING LIST-BASED CRUD, PAGING AND SORTING FUNCTIONALITIES TO A REPOSITORY:
package PackageName;

//for JPA
import org.springframework.data.jpa.repository.ListCrudRepository;
import org.springframework.data.jpa.repository.ListPagingAndSortingRepository;
import org.springframework.data.jpa.repository.Modifying;
import org.springframework.data.jpa.repository.Query;
//for MongoDB
import org.springframework.data.mongodb.repository.ListCrudRepository;
import org.springframework.data.mongodb.repository.ListPagingAndSortingRepository;
import org.springframework.data.mongodb.repository.Modifying;
import org.springframework.data.mongodb.repository.Query;
//for all
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.*;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Pageable;
import org.springframework.data.domain.Sort;
import org.springframework.data.domain.Sort.Order;

@Repository
public interface RepositoryClassName extends
        ListCrudRepository<EntityClassName, TypeOfID>,
        ListPagingAndSortingRepository<EntityClassName, TypeOfID> {
    ...
}
END OF EXAMPLE

The next interfaces are extended from the CrudRepository for special purposes.

||Interface|Description||
||ReactiveCrudRepository|adds CRUD support to Reactive stores||
||ReactiveSortingRepository|adds sorting operations to Reactive stores||
||RxJava3CrudRepository|adds CRUD support of RxJava||
||RxJava3SortingRepository|adds sorting support to RxJava||
||CoroutineCrudRepository|adds CRUD support to Kotlin coroutines||
||CoroutineSortingRepository|adds sorting support to Kotlin coroutines||

=================================================================================
2. SPRING DATA JPA
=================================================================================
2.1. ABOUT SPRING DATA JPA
2.2. JPA INTERFACES
2.3. METHODOLOGY OF SAVING AND MODIFYING
2.4. DERIVED QUERY METHODS
2.5. CUSTOM QUERY METHODS
2.6. QUERIES WITH DYNAMIC SORTING
2.7. QUERIES WITH DYNAMIC PAGINATION
2.8. QUERY EXAMPLES
2.9. UNIQUE REPOSITORY INTERFACE
2.10. SPECIALS

2.1. ABOUT SPRING DATA JPA
---------------------------------------------------------------------------------
The Spring Data JPA framework is designed to make a bridge between backend repositories and SQL databases.
The JPA stands for Jakarta Persistence API (before Spring 3, Java Persistence API).
JPA is a layer above Hibernate which is integrated into Spring Data.

2.2. JPA INTERFACES
---------------------------------------------------------------------------------
Spring offers a complex interface:
    - JpaRepository: adds the functionality of the CrudRepository extended by Collection, Stream, paging, sorting and exampling support, and can return both Iterables and Lists for more elements

It is important that all functionality provided by the interface, will be translated into SQL commands by Hibernate and sent to the database as queries.
The database will interpret and process, then send data back to the backend.

EXAMPLE FOR A JPA REPOSITORY INTERFACE:
package PackageName;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Modifying;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.*;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Pageable;
import org.springframework.data.domain.Sort;
import org.springframework.data.domain.Sort.Order;

@Repository
public interface RepositoryClassName extends JpaRepository<EntityClassName, TypeOfID> {
    //optional fields
    //optional overridden default methods
    //optional derived query methods
    //optional custom query methods
    //optional helper methods
}
END OF EXAMPLE

By extending the JPA repository, the next inherited methods will be accessible. The access can happen from within the repository class or from the service class into which the repository was injected.
The entity is the element of the table of the database defined with @Entity under Spring, accessible via the repository.
Coming from design, it is possible to manage entity management via the repository or via the service.
These methods are satisfying basic needs of handling database data, mainly satisfying CRUD functions.
The findByID method identifies the ID field defined in the element class and uses that. That means, the name of the actual ID field can be different, however best practice is to use id as a name for better readability, compatibility, and to prevent future coding errors.

||Method|Description||
||existsById(id)|returns existence of the entity by the ID||
||getReferenceById(id)|returns a specific entity by ID||
||findById(id)|returns an Optional of entity by ID||
||findAllById(iterableOfIds)|returns a List of entities found by IDs||
||findAll()|returns a List of all entities||
||save(entity)|adds the passed entity to the repository, or modifies an existing one||
||saveAll(iterableOfEntities>)|adds the passed entities to the repository, modifies existing ones||
||flush()|writes all entities to the storage, which were kept in repository for buffering||
||count|returns the long number of entities stored in the repository||
||delete(entity)|finds and deletes the passed entity from the repository||
||deleteAll(iterableOfEntities)|finds and deletes entities of the passed Iterable||
||deleteById(id)|finds and deletes the entity by ID||
||deleteAllById(iterableOfIds)|finds and deletes entities by their IDs of the passed Iterable||
||deleteAll|empties the repository||

2.3. METHODOLOGY OF SAVING AND MODIFYING
---------------------------------------------------------------------------------
The Spring Data JPA offers the same two default methods for both functions. The separator behind saving and modifying an entity is the existence of an entity by its ID (or if present, the version number).
Visit the SPRING BOOT ENTITY page for ID and version definition and constructors of an entity.

The methodology for saving as new (without version field) is as follows:
    - create a new entity without defining its ID
    - save it
    - will return the saved entity with its ID

The methodology for modifying is as follows (without version field):
    - load the original entity (will contain its original ID)
    - modify its field values by calling proper setters (except the ID)
    - in case of modified entity, Spring Data JPA will call it dirty
    - dirty entities will be saved automatically by Spring Data JPA at next flushing procedure
    - in case of using Spring Data, save it manually (for better compatibility and safety, always call save() or saveAll())
    - will return the full saved entity

The methodology for saving as new is as follows (with version field):
    - create a new entity without defining its ID and version (leave them null for object or 0 for primitive)
    - save it
    - will return the saved entity with its new ID and version

The methodology for modifying is as follows (with version field):
    - load the original entity (will contain its original version)
    - modify its field values by calling proper setters (except the ID)
    - modify the version
    - in case of modified entity, Spring Data JPA will call it dirty
    - dirty entities will be saved automatically by Spring Data JPA at next flushing procedure
    - in case of using Spring Data, save it manually (for better compatibility and safety, always call save() or saveAll())
    - will return the full saved entity

Because the existence of ID (or version) is the procedure separator, when the ID (or version) is not found in the table, will save the entity as new.
If the entity has version field but it is not defined (null or 0), JPA will fall back to ID checking.
As for every repository actions, using the flush() method is optional, use it when data upgrade must be immediate on database side.

EXAMPLE FOR SAVING AN ENTITY:
//the repository is named repo
EntityClass entity = new EntityClass(...); //constructor without entity ID
EntityClass savedEntity = repo.save(entity);
//savedEntity contains given field values plus the ID in the table
END OF EXAMPLE

EXAMPLE FOR SAVING ENTITIES:
//the repository is named repo
List<EntityClass> entities = new ArrayList<>();
entities.add(new EntityClass(...)); //constructor without entity ID
entities.add(new EntityClass(...)); //constructor without entity ID
...
repo.saveAll(entities);
END OF EXAMPLE

EXAMPLE FOR MODIFYING AN ENTITY (EXCEPTION IF NO PREVIOUS ELEMENT):
//the repository is named repo
long id = ...; //the ID of the element in the table we would like to modify
Optional<EntityClass> entity = repo.findById(id); //the ID field will contain ID of the element as well
if (entity.isEmpty()) {
    throw new RuntimeException("Element does not exist, unable to modify.");
}
//call setters of entity for setting new values on the entity
EntityClass savedEntity = repo.save(entity); //modifies the element defined by its ID
END OF EXAMPLE

EXAMPLE FOR MODIFYING AN ENTITY (SAVE NEW IF NON-EXISTENT):
//the repository is named repo
EntityClass entity = new EntityClass(...); //constructor with probable ID
EntityClass savedEntity = repo.save(entity); //modifies the element defined by its ID, or if ID non-existent, saves as new element on the given ID
END OF EXAMPLE

EXAMPLE FOR MODIFYING ENTITIES (COLLECT IDS OF NON-EXISTENT):
//the repository is named repo
List<Long> ids = ...; //the IDs of elements in the table we would like to modify
List<EntityClass> entities = repo.findAllById(ids); //will contain only the found entities, the ID field per entity will contain ID of the given element as well
List<Long> foundIds = entities.stream()
        .map(EntityClass::getId)
        .toList();
List<Long> notFoundIds = ids.stream()
        .filter(id -> !foundIds.contains(id))
        .toList();
//call setters of elements of entities for setting new values on the given entity
repo.saveAll(entities); //modifies the elements defined by their IDs
END OF EXAMPLE

2.4. DERIVED QUERY METHODS
---------------------------------------------------------------------------------
The default interface is for saving data and finding-managing data by the ID (CRUD or JPA functions).
In case of other or overridden methods are needed, can be coded on repository level.

It is important that all functionality provided by the interface, will be translated into SQL commands by Hibernate and sent to the database as queries.
Therefore, the database will interpret and process, then send data back to the backend.

The JPA repository offers conventions for new query methods, by utilizing them derived methods can be defined.
All derived query methods should be defined as abstract only.
Names of derived query methods are built from given keywords (see later), JPA will automatically fill the method with the right code.
A derived query method usually has argument list, its variable names must be used in the method name in respective order.

The main keywords are for identifying the main purpose of the query.
The find keyword can be replaced with read, get, query, search or stream keywords. In case of stream, a Stream result type would be advised.
The remove keyword deletes elements as the delete, but returns the removed elements.

A derived query method does not need explicit SQL expression to work since the theory behind is to have a verbal method name made of keywords. However, for better visual interpretation only, the @Query annotation can be used optionally in the way described with custom query methods, see later.

||Main keyword|Description|SQL sample||
||find[...]By...|general query for finding data|SELECT ... FROM ... WHERE ...||
||read[...]By...|general query for finding data|SELECT ... FROM ... WHERE ...||
||get[...]By...|general query for finding data|SELECT ... FROM ... WHERE ...||
||query[...]By...|general query for finding data|SELECT ... FROM ... WHERE ...||
||search[...]By...|general query for finding data|SELECT ... FROM ... WHERE ...||
||stream[...]By...|general query for finding data|SELECT ... FROM ... WHERE ...||
||exists[...]By...|returns typically a boolean value|SELECT EXISTS ... FROM ... WHERE ...||
||count[...]By...|returns a numeric value|SELECT COUNT ... FROM ... WHERE ...||
||delete[...]By...|deletion query, returns void or number of deleted rows|DELETE FROM ... WHERE ...||
||remove[...]By...|deletion query, returns void or number of deleted rows|DELETE FROM ... WHERE ...||
||...First[number]...By..., ...Top[number]...By...|used somewhere between find and By keywords; restricts the found elements for their first appearance (possible found maximum number of rows are defined with the number value, if left, means first only)|SELECT TOP ... ... FROM ... WHERE ...||
||...distinct...By...|results unique values for the marked column etc.|SELECT DISTINCT ... FROM ... WHERE ...||

EXAMPLE FOR QUERY METHOD AGAINST SQL:
//repository type: CRUD
//domain name defined in element class: Customers
//domain ID type in element: Long
//domain field in element: lastname
//table name in database: customers
//field name in database: surname

interface UserRepository extends CrudRepository<Customers, Long> {
    //count
    long countByLastname(String lastname);
    //SQL: SELECT COUNT * FROM customers WHERE surname = lastname;
}
END OF EXAMPLE

The additional keywords are used together with main keywords (usually with find).
Except for AllIgnoreCase and AllIgnoringCase, every additional keywords can be used for a column only which means for multiple fields different keywords can be used.

||Additional keyword|Example|SQL sample||
||Distinct|findDistinctByLastnameAndFirstname|SELECT DISTINCT ... WHERE ... (returns only unique results)||
||And|findByLastnameAndFirstname|... WHERE x.lastname = ?1 AND x.firstname = ?2||
||Or|findByLastnameOrFirstname|... WHERE x.firstname = ?1 OR x.lastname = ?2||
||Is, Equals|findByFirstname, findByFirstnameIs, findByFirstnameEquals|... WHERE x.firstname = ?1||
||IsEmpty, Empty|findByFirstnameIsEmpty, findByFirstnameEmpty|... WHERE x.firstname IS EMPTY||
||IsNotEmpty, NotEmpty|findByFirstnameIsNotEmpty, findByFirstnameNotEmpty|... WHERE x.firstname NOT EMPTY||
||Between|findByStartDateBetween|... WHERE x.startdate BETWEEN ?1 AND ?2||
||LessThan|findByAgeLessThan|... WHERE x.age < ?1||
||LessThanEqual|findByAgeLessThanEqual|... WHERE x.age <= ?1||
||GreaterThan|findByAgeGreaterThan|... WHERE x.age > ?1||
||GreaterThanEqual|findByAgeGreaterThanEqual|... WHERE x.age >= ?1||
||Near, IsNear|findByAgeNear, findByAgeIsNear|... WHERE ABS(x.age - ?1) < ?2||
||Within, IsWithin|findByAgeWithin, findByAgeIsWithin|... WHERE x.age >= ?1 OR x.age <= ?2||
||After|findByStartDateAfter|... WHERE x.startdate > ?1||
||Before|findByStartDateBefore|... WHERE x.startdate < ?1||
||IsNull, Null|findByAgeIsNull, findByAgeNull||... WHERE x.age IS NULL||
||IsNotNull, NotNull|findByAgeIsNotNull, findByAgeNotNull||... WHERE x.age NOT NULL||
||Like|findByFirstnameLike|... WHERE x.firstname LIKE ?1||
||NotLike|findByFirstnameNotLike|... WHERE x.firstname NOT LIKE ?1||
||StartingWith|findByFirstnameStartingWith|... WHERE x.firstname LIKE ?1 (?1 is e.g. "abc%")||
||EndingWith|findByFirstnameEndingWith|... WHERE x.firstname LIKE ?1 (?1 is e.g. "%abc")||
||Containing|findByFirstnameContaining|... WHERE x.firstname LIKE ?1 (?1 is e.g. "%abc%")||
||OrderBy|findByAgeOrderByLastnameDesc|... WHERE x.age = ?1 ORDER BY x.lastname DESC (or Asc for ASC)||
||Not|findByLastnameNot|... WHERE x.lastname <> ?1||
||In|findByAgeIn(Collection<Age> ages)|... WHERE x.age IN ?1 (accepts any Collection type or varargs)||
||NotIn|findByAgeNotIn(Collection<Age> ages)|... WHERE x.age NOT IN ?1 (accepts any Collection type or varargs)||
||True|findByActiveTrue|... WHERE x.active = TRUE||
||False|findByActiveFalse|... WHERE x.active = FALSE||
||IgnoreCase, IgnoringCase|findByFirstnameIgnoreCase, findByFirstnameIgnoringCase|... WHERE UPPER(x.firstname) = UPPER(?1) (same with LOWER() method)||
||AllIgnoreCase, AllIgnoringCase|findByFirstnameAndLastnameAllIgnoreCase, findByFirstnameAndLastnameAllIgnoringCase|... WHERE UPPER(x.firstname) = UPPER(?1) (same with LOWER() method)||
||Regex, MatchesRegex, Matches|findByFirstnameRegex, findByFirstnameMatchesRegex, findByFirstnameMatches|-||

Using the Distinct keyword needs careful consideration:
    - SELECT DISTINCT u FROM User u (because it includes User.id, nothing will be duplicated, result will be the whole table e.g. in a List<User>)
    - SELECT DISTINCT u.lastname FROM User u (narrows the query for User.lastname and finds unique values for that, result can be either List<User> and List<String>)
    - countDistinctByLastname(String lastname) (equals with SELECT COUNT(DISTINCT u.id) FROM User u WHERE u.lastname = ?1, because u.id contains unique values, result equals with countByLastname(String lastname))
In case of better verbal and cleaner query, it can be advised to use the @Query annotation with custom method name.

The return value of the query method depends on the query.
Basically, the return value can be single (e.g. the entity class or a primitive) or multiple (e.g. a Collection subtype like List).
In case of single, the query can produce result or null. The syntax will be correct when the return value is a class, however, packaging the result type into an Optional is preferred for preventing runtime exception when invoking the query does not find matching data. Also, instead of Optional, List can be used of which size will be zero in case of no found element.
In case a query could result multiple values it is advised to define multiple return value for the method. By defining single and the query returns single in a specific case, no error will appear but because the method is capable to produce multiple elements, in such situation, IncorrectResultSizeDataAccessException will be raised.
For geospatial returned data, GeoResult (single) or result wrapper like GeoPage or GeoResults as multiple data can be used.
In case the method return type is different from what the query would produce but convertible, JPA will convert it automatically, if not possible, exception will be raised.

Return types can be:
    - void
    - primitive type (long, boolean etc.)
    - wrapper types (Long, String etc.)
    - T (unique entity, the query must produce a single result at most, if none, null will be returned)
    - Iterator<T>
    - Collection<T> (superclass of List, Map and Set)
    - List<T>
    - Optional<T> (the query must produce a single result at most, if none, Optional will be empty)
    - Option<T> (Scala or Vavr class, similar to Optional)
    - Stream<T>
    - Streamable<T> (extension of Collection<T> for convenience)
    - Seq, List, Map, Set (Vavr classes)
    - Future<T> (expects a method to be annotated with @Async and requires Spring’s asynchronous method execution capability to be enabled)
    - CompletableFuture<T> (expects a method to be annotated with @Async and requires Spring’s asynchronous method execution capability to be enabled)
    - Slice<T> (a sized chunk of data with an indication of whether there is more data available. Requires a Pageable method parameter)
    - Page<T> (Slice with additional information such as the total number of results, requires a Pageable method parameter)
    - GeoResult<T> (result entry with additional information, such as the distance to a reference location)
    - GeoResults<T> (a list of GeoResult<T> with additional information, such as the average distance to a reference location)
    - GeoPage<T> (a Page with GeoResult<T>, such as the average distance to a reference location)
    - Mono<T> (a Project Reactor Mono emitting zero or one element using reactive repositories; expects the query method to return one result at most; if no result is found, Mono.empty() is returned; more than one result triggers an IncorrectResultSizeDataAccessException)
    - Flux<T> (a Project Reactor Flux emitting zero, one, or many elements using reactive repositories; queries returning Flux can emit also an infinite number of elements)
    - Single<T> (a RxJava Single emitting a single element using reactive repositories; expects the query method to return one result at most; if no result is found, Mono.empty() is returned; more than one result triggers an IncorrectResultSizeDataAccessException)
    - Maybe<T> (a RxJava Maybe emitting zero or one element using reactive repositories; expects the query method to return one result at most; if no result is found, Mono.empty() is returned; more than one result triggers an IncorrectResultSizeDataAccessException)
    - Flowable<T> (a RxJava Flowable emitting zero, one, or many elements using reactive repositories; queries returning Flowable can emit also an infinite number of elements)

MORE HERE: https://www.baeldung.com/spring-data-jpa-query

2.5. CUSTOM QUERY METHODS
---------------------------------------------------------------------------------
The @Query method-level annotation is used for a query method:
    - for increasing readability of name of a derived query method (usage is optional, see earlier)
    - for defining JPQL or native SQL expression of the query (custom query methods; usage is a must)

It is important that all functionality provided by the interface, will be translated into SQL commands by Hibernate and sent to the database as queries.
Therefore, the database will interpret and process, then send data back to the backend.

The JPQL stands for Jakarta Persistence Query Language (former Java Persistence Query Language), it is a platform-independent object-oriented query language defined as part of the Jakarta Persistence API (JPA; formerly Java Persistence API) specification. JPQL is inspired by SQL, and its queries resemble SQL queries in syntax, but operate against JPA entity objects stored in a relational database rather than directly with database tables.
The JPQL only supports a subset of SQL standard. If you want to make complex queries, use native SQL query.
Spring Data JPA does not adjust the query to specific SQL dialect of the database, so ensure that the provided statement is supported by RDBMS.

The query method arguments are accessed in the query with:
    - positional parameters (?1, ?2, ... respectively)
    - named parameters (:argumentName1, :argumentName2)
In case of named parameters, when the referenced :argumentNameX needs emphasis, the @Param annotation is needed in method signature.

EXAMPLE FOR POSITIONAL PARAMETERS:
@Query("SELECT e FROM entity_table e WHERE e.title = ?1 AND e.year = ?2")
List<Entity> entities = findEntities(String s, int n);
END OF EXAMPLE

EXAMPLE FOR NAMED PARAMETERS:
@Query("SELECT e FROM entity_table e WHERE e.title = :title AND e.year = :year") //JPQL
@Query(value = "SELECT * FROM entity_table e WHERE e.title = :title AND e.year = :year", nativeQuery = true) //native SQL
List<Entity> entities = findEntities(String title, int year); //no emphasis
List<Entity> entities = findEntities(@Param("title") String s, @Param("year") int n); //emphasis
END OF EXAMPLE

The arguments of @Query annotations can be:
    - "JPQL expression"
    - value = "JPQL expression"
    - value = "native SQL expression", nativeQuery = true

Custom query methods must not use keywords as they are used with derived query methods since Spring uses names of derived methods over @Query expressions in priority.
The table from the data should be queried is marked with FROM keyword in SQL. The table name is not equal with the entity class name, instead use the name given with the @Table annotation in the entity class.
The native SQL contains the CONCAT() function which concatenates its arguments into one text (e.g. "CONCAT('%', ?1,'%')").
In order to match value case-insensitively, the column value and the method parameter should be modified with UPPER() or LOWER() function (e.g. "UPPER(e.title) LIKE UPPER(?1%)").

2.6. QUERIES WITH DYNAMIC SORTING
---------------------------------------------------------------------------------
Method arguments can overwrite the query expression, this is called dynamic sorting, paging etc. Meaning, the expression is invoked but after that, the query method will invoke the dynamic operation on the results before passing the results to its caller side.
When using dynamic modification, avoid using similar expression part in the query (would take more operation time, result can be unpredicted).

Dynamic sorting means that to the method signature a Sort object is added. Therefore, the query expression should not contain ORDER BY part but the method signature will modify the expression by adding sorting afterwards.
Spring Data JPA does not currently support dynamic sorting for native SQL queries (will raise InvalidJpaQueryMethodException), because it would have to manipulate the actual query declared, which it cannot do reliably for native SQL. For native SQL, add Pageable object instead, see examples.

In the repository interface, a Sort object can be given as the last argument of the query method:
    - List<EntityClass> queryMethodName([other parameters, ]Sort sort);
This argument will receive dynamic sorting properties upon invoking in the Business layer.

The passed sorting properties can be defined:
    - by declaring a variable (re-usable)
    - directly passed to the query method upon invoking (no variable, use-once)

A Sort object can be created by calling the by() static method of Sort:
    - Sort sort = Sort.by("fieldName"); //natural sorting
    - Sort sort = Sort.by("fieldName").descending(); //reversed sorting

In case of hierarchic sorting, sorting levels can be added by chaining the and() method of Sort to the previous Sort object

EXAMPLE FOR CHAINING SORTS:
Sort sort = Sort.by("fieldName1")[.descending()]
        .and(Sort.by("fieldName2")[.descending()])
        .and(...);
END OF EXAMPLE

The hierarchic sorting is possible via creating Order objects for every sorting levels, render them into a List, and passing this List (or an element or a sublist of it) to the by() method:
    - Sort sort = Sort.by(orders);

An Order object can be created:
    - Order order = new Order(Sort.Direction.ASC, "fieldName");
    - Order order = new Order(Sort.Direction.DESC, "fieldName");

The List of entities can be queried by invoking:
    - List<EntityClass> = repositoryName.queryMethodName([other parameters, ]sort);
    - List<EntityClass> = repositoryName.queryMethodName([other parameters, ]Sort.by(...));

2.7. QUERIES WITH DYNAMIC PAGINATION
---------------------------------------------------------------------------------
Dynamic pagination means that the query presents only one part of the whole set of results, and with paging command will present the next package in order. By using it the data traffic between the database and the backend becomes reduced, the operation becomes faster.
With pagination, sorting and filtering is possible as well.

In the repository interface, a Pageable object can be given as the last argument of the query method:
    - Page<EntityClass> queryMethodName([other parameters, ]Pageable pageable);
This argument will receive dynamic paging properties upon invoking in the Business layer.

The passed paging properties can be defined:
    - by declaring a variable (re-usable)
    - directly passed to the query method upon invoking (no variable, use-once)

A Pageable object can be created by calling the of() static method of PageRequest:
    - Pageable pageable = PageRequest.of(pageNumber, pageSize); //no sorting
    - Pageable pageable = PageRequest.of(pageNumber, pageSize, sort); //with sorting, sort is instance of Sort
The pageNumber must be non-negative, first page is the zeroth.
The pageSize means the number of entities the returned package contains, must be positive.

A page request queried by invoking:
    - Page<EntityClass> page = repositoryName.queryMethodName([other parameters, ]pageable);
    - Page<EntityClass> page = repositoryName.queryMethodName([other parameters, ]PageRequest.of(...));

The List of entities of a page can be extracted by invoking:
    - List<EntityClass> = page.getContent();
    - List<EntityClass> = repositoryName.queryMethodName([other parameters, ]pageable).getContent();
    - List<EntityClass> = repositoryName.queryMethodName([other parameters, ]PageRequest.of(...)).getContent();

||Pageable method|Description||
||first()|queries the first page||
||previousOrFirst()|queries the previous page or the first if the actual is the first||
||next()|queries the next page||
||hasPrevious()|is there a page before the actual||
||toOptional()|packages the Pageable into an Optional||
||getOffset()|gets the offset based on the actual number of page and the page size||
||getPageNumber()|returns the actual page number||
||getPageSize()|returns the size of page (number of contained entities)||
||getSort()|returns the sorting parameters as a Sort||
||getSortOr(Sort sort)|returns the sorting parameters or the given argument if Pageable is unsorted||
||isPaged()|returns whether the Pageable contains pagination information||
||isUnpaged()|returns whether the Pageable does not contain pagination information||
||ofSize(int pageSize)|creates a new Pageable for the first page (page number 0) given pageSize||
||unpaged()|creates a new Pageable without pagination parameters||
||withPage(int pageNumber)|creates a new Pageable with pageNumber applied||

||Page method|Description||
||empty()|creates a new, empty page||
||empty(Pageable pageable)|creates a new, empty page for the given Pageable||
||getTotalElements()|returns the total number of elements||
||getTotalPages()|returns the total number of pages||
||map(Function<? super T,? extends U> converter)|returns a new Page with the content of the current one mapped by the given Function||
||forEach(...)|invokes a lambda on every elements||
||iterator|returns an Iterator of elements||
||getContent|retrieves the List of items in the page||
||getNumber()|returns the number of the actual page||
||getNumberOfElements()|returns the number of elements in the Page||
||getPageable()|returns the Pageable||
||getSize()|returns the size of the Page (number of elements)||
||getSort()|returns the sorting parameters as Sort||
||hasContent()|returns whether the Page has content||
||hasNext()|checks whether there is a next Page||
||hasPrevious()|checks whether there is a previous Page||
||isFirst()|checks whether the actual Page is the first||
||isLast()|checks whether the actual Page is the last||
||nextOrLastPageable()|returns the next Pageable or the last if the actual is the last||
||nextPageable()|returns the next Pageable||
||previousOrFirstPageable()|returns the previous Pageable or the first if the actual is the first||
||previousPageable()|returns the previous Pageable||

2.8. QUERY EXAMPLES
---------------------------------------------------------------------------------
Visit the SPRING BOOT REPOSITORY QUERY EXAMPLES page for derived, custom and dynamic query examples.

2.9. UNIQUE REPOSITORY INTERFACE
---------------------------------------------------------------------------------
If you do not want to extend your repository with all the methods of the given standard interface, you can define your own repository:
    - add the @RepositoryDefinition class-level annotation to the @Repository class
    - copy-paste code of the needed method from the original code of the interface
    - carefully choose the return type of your own method for multiple values (Iterable<T> or List<T> or Collection<T> or VAVR list, JPA will flexibly execute your method)

If you want to use your own interface for many repositories, you can define a Spring bean:
    - create your unique interface
    - mark it with @NoRepositoryBean (this prevents Spring to create an instant from it which would result a fail because there is no entity for such interface)
    - create your repositories by extending this bean

EXAMPLE FOR DEFINING AND EXTENDING UNIQUE REPOSITORY INTERFACE:
/*
Define a new common generics interface which:
    - inherits the Repository interface of JPA
    - adds findById() and save() method signatures
    - Spring will match these two methods by their method signatures and copy the codes from CrudRepository
    - this interface will have only these two methods from CrudRepository
*/
@NoRepositoryBean
interface MyBaseRepository<T, ID> extends Repository<T, ID> {

    Optional<T> findById(ID id);

    <S extends T> S save(S entity);
}
/*
Define repositories by extending MyBaseRepository
In this example:
    - T will match with User class
    - Long will match with ID class
    - adds findByEmailAddress() method to this specific repository
*/
interface UserRepository extends MyBaseRepository<User, Long> {
    User findByEmailAddress(EmailAddress emailAddress);
}
END OF EXAMPLE

2.10. SPECIALS
---------------------------------------------------------------------------------
For EntityManager, SQL LIKE on PostgreSQL text array column, named queries and query rewriter, visit the SPRING BOOT REPOSITORY SPECIALS page.

MORE HERE: Using Advanced LIKE Expressions, https://docs.spring.io/spring-data/jpa/docs/current/reference/html/#jpa.query-methods

=================================================================================
3. SPRING DATA MONGODB
=================================================================================
3.1. ABOUT SPRING DATA MONGODB
3.2. MONGODB INTERFACES

3.1. ABOUT SPRING DATA MONGODB
---------------------------------------------------------------------------------
The Spring Data MongoDB framework is designed to make a bridge between backend repositories and MongoDB NoSQL databases.
The Hibernate is not part of the MongoDB solution under Spring since it is mainly for relational databases. However, it is possible to use Hibernate OGM as a lower layer under Spring Data MongoDB.

3.2. MONGODB INTERFACES
---------------------------------------------------------------------------------
Spring offers a complex interface:
    - MongoRepository: adds the functionality of the CrudRepository extended by Collection, Stream, paging, sorting and exampling support, and can return both Iterables and Lists for more elements

=================================================================================
4. THE SPRING DATA DOMAIN-REPOSITORY CHAIN
=================================================================================
The Spring Data frameworks are designed to make a bridge between backend repositories and databases.
Utilizing this framework is different when using without and with Spring Boot (annotations, interfaces etc). Generally, through Spring Boot it became easier, simpler and faster for coding.
The reason is that Spring Boot is designed to be the top bridge above different Spring frameworks.

In Spring Data, when not using unique repository class, repository will be an interface which extends an abstract interface provided by Spring Data.
In the class chain from domain to controller, the repository level is directly above the domain level.
The chained domain definition declares which Spring repository archetype will be initialized (e.g. Data JPA or Data MongoDB).
The chained line must be certain. A repository can not use but one domain type.

The chain can be defined by
    - the inheriting hierarchy (see examples below)
    - the main class as annotation
    - a configuration class as annotation
Try to avoid using multiple methods for chain definitions.
Visit the SPRING BOOT CONFIGURATION and SPRING BOOT MAIN CLASS pages for more information.

EXAMPLE FOR CERTAIN DOMAIN-REPOSITORY CHAIN:
//JPA
//domain definition using @Entity annotation, class name is EntityClassName

@Repository
interface MyRepository extends Repository<EntityClassName, Long> {
//Spring will use Spring Data JPA when creates the repository instance
}

//JPA with CRUD
//domain definition using @Entity annotation, class name is EntityClassName

@Repository
interface MyRepository extends CrudRepository<EntityClassName, Long> {
//Spring will use Spring Data JPA when creates the repository instance
}

//MongoDB
//domain definition using @Document annotation, class name is DocumentClassName

@Repository
interface MyRepository extends Repository<DocumentClassName, Long> {
//Spring will use Spring Data MongoDB when creates the repository instance
}

//with unique repository
//domain definition using @Entity or @Document annotation, class name is DomainClassName

@NoRepositoryBean
interface StandardRepository extends Repository<DomainClassName, Long> {
//Spring will not create instance
//archetype is chained from domain
...
}

@Repository
interface MyRepository extends StandardRepository<DomainClassName, Long> {
//Spring will use the proper archetype
}
END OF EXAMPLE

EXAMPLE FOR UNCERTAIN DOMAIN-REPOSITORY CHAIN:
//Generics example
//domain definition of any kind, class name is DomainClassName

@NoRepositoryBean
interface StandardRepository extends Repository<T, ID> {
//Spring does not know that T equals with the domain class
//Spring will not create instance based on the used annotation
...
}

@Repository
interface MyRepository extends StandardRepository<DomainClassName, Long> {
//there is no link between the domain and the StandardRepository, Spring fails to determine the archetype
}

//no-generics example
//domain definition using @Entity and @Document annotations together, class name is DomainClassName

@Repository
interface MyRepository extends Repository<DomainClassName, Long> {
//Spring Data fails to determine which archetype should be chained
}
END OF EXAMPLE

=>SPRING BOOT
=>SPRING BOOT ENTITY
=>SPRING BOOT ENTITY JOIN
=>SQL AND NOSQL DATABASES
=>SQL SELECT
=>POSTGRESQL
=>H2
=>SPRING BOOT REPOSITORY QUERY EXAMPLES
=>SPRING BOOT REPOSITORY SPECIALS
=>SPRING BOOT TESTS;3. REPOSITORY TESTS
=>SPRING DATA JPA TESTS
=>SPRING APPLICATION PROPERTIES
=>SPRING BOOT CONFIGURATION
=>SPRING BOOT MAIN CLASS
